// Generated by CoffeeScript 1.9.3
var Roller,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Roller = (function() {
  var cubeSize, generateLights, generateStars, generateThings, numberOfStars, numberOfThings, rotate, rotateBy;

  numberOfThings = 30;

  numberOfStars = 2000;

  rotateBy = 0.04;

  cubeSize = 10;

  function Roller() {
    this.renderLoop = bind(this.renderLoop, this);
    this.render = bind(this.render, this);
    this.update = bind(this.update, this);
    this.onWindowResize = bind(this.onWindowResize, this);
    var j, k, len, len1, light, ref, ref1, thing;
    this.scene = new THREE.Scene();
    this.camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);
    this.renderer = new THREE.WebGLRenderer();
    this.controls = new THREE.OrbitControls(this.camera);
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(this.renderer.domElement);
    this.things = generateThings();
    ref = this.things;
    for (j = 0, len = ref.length; j < len; j++) {
      thing = ref[j];
      this.scene.add(thing);
    }
    this.stars = generateStars();
    this.scene.add(this.stars);
    this.camera.position.z = 200;
    ref1 = generateLights();
    for (k = 0, len1 = ref1.length; k < len1; k++) {
      light = ref1[k];
      this.scene.add(light);
    }
    window.addEventListener('resize', this.onWindowResize, false);
  }

  Roller.prototype.onWindowResize = function() {
    console.log('foo');
    this.camera.aspect = window.innerWidth / window.innerHeight;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    return console.log('bar');
  };

  generateLights = function() {
    var ambientLight, blueLight, redLight, whiteLight;
    ambientLight = new THREE.AmbientLight(0x332222);
    redLight = new THREE.PointLight(0xaa2322, 1, 1000);
    redLight.position.set(30, 20, 20);
    blueLight = new THREE.PointLight(0x0000ff, 1, 1000);
    blueLight.position.set(-30, -20, -20);
    whiteLight = new THREE.PointLight(0xffffff, 1, 1000);
    whiteLight.position.set(30, 80, 20);
    return [ambientLight, redLight, blueLight, whiteLight];
  };

  generateThings = function() {
    var geometry, j, material, r, ref, results, thing;
    geometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
    material = new THREE.MeshPhongMaterial({
      wireframe: true,
      wireframeLinewidth: 4
    });
    results = [];
    for (r = j = 1, ref = numberOfThings; 1 <= ref ? j <= ref : j >= ref; r = 1 <= ref ? ++j : --j) {
      thing = new THREE.Mesh(geometry, material);
      thing.position.x = r * cubeSize - numberOfThings * 5;
      thing.rotation.x = r / numberOfThings * Math.PI / 2;
      results.push(thing);
    }
    return results;
  };

  generateStars = function() {
    var i, j, material, ref, star, starGeo, stars, xyz;
    starGeo = new THREE.Geometry;
    for (i = j = 1, ref = numberOfStars; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
      xyz = (function() {
        var k, results;
        results = [];
        for (i = k = 1; k <= 3; i = ++k) {
          results.push(Math.random() * 500 - 250);
        }
        return results;
      })();
      star = new THREE.Vector3(xyz[0], xyz[1], xyz[2]);
      starGeo.vertices.push(star);
    }
    material = new THREE.PointCloudMaterial({
      size: 0.5,
      color: 0xffffff
    });
    stars = new THREE.PointCloud(starGeo, material);
    stars.rotation.x = Math.random() * 6;
    stars.rotation.y = Math.random() * 6;
    stars.rotation.z = Math.random() * 6;
    return stars;
  };

  rotate = function(thing) {
    return thing.rotation.x += rotateBy;
  };

  Roller.prototype.update = function() {
    var j, len, ref, thing;
    ref = this.things;
    for (j = 0, len = ref.length; j < len; j++) {
      thing = ref[j];
      rotate(thing);
    }
    return this.stars.rotation.y += 0.0005;
  };

  Roller.prototype.render = function() {
    return this.renderer.render(this.scene, this.camera);
  };

  Roller.prototype.renderLoop = function(animate) {
    if (animate == null) {
      animate = true;
    }
    this.update();
    requestAnimationFrame(this.renderLoop);
    return this.render();
  };

  return Roller;

})();
