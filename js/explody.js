// Generated by CoffeeScript 1.9.3
var Explody,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Explody = (function() {
  var generateParticles, params;

  params = {
    numberOfParticles: 5000,
    speed: 2,
    size: 2,
    fadeDistance: 300,
    random: false,
    initialSphereRadius: 5
  };

  function Explody() {
    this.renderLoop = bind(this.renderLoop, this);
    this.render = bind(this.render, this);
    this.update = bind(this.update, this);
    this.createGUI = bind(this.createGUI, this);
    this.onWindowResize = bind(this.onWindowResize, this);
    this.reInit = bind(this.reInit, this);
    this.init = bind(this.init, this);
    this.scene = new THREE.Scene();
    this.camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);
    this.renderer = new THREE.WebGLRenderer();
    this.controls = new THREE.OrbitControls(this.camera);
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(this.renderer.domElement);
    this.init();
  }

  Explody.prototype.init = function() {
    this.camera.position.z = 200;
    this.camera.position.y = 200;
    this.camera.position.x = 200;
    this.camera.lookAt(new THREE.Vector3(0, 0, 0));
    this.particles = generateParticles();
    this.scene.add(this.particles);
    this.createGUI();
    return window.addEventListener('resize', this.onWindowResize, false);
  };

  Explody.prototype.reInit = function() {
    this.scene.remove(this.particles);
    this.particles = null;
    return this.init();
  };

  Explody.prototype.onWindowResize = function() {
    this.camera.aspect = window.innerWidth / window.innerHeight;
    this.camera.updateProjectionMatrix();
    return this.renderer.setSize(window.innerWidth, window.innerHeight);
  };

  Explody.prototype.createGUI = function() {
    if (this.gui) {
      return;
    }
    this.gui = new dat.GUI({
      height: 5 * 32 - 1
    });
    this.gui.add(params, 'numberOfParticles').min(100).max(50000).step(100).onFinishChange((function(_this) {
      return function() {
        return _this.reInit();
      };
    })(this));
    this.gui.add(params, 'size').min(0.5).max(10).step(0.3).onFinishChange((function(_this) {
      return function() {
        return _this.reInit();
      };
    })(this));
    this.gui.add(params, 'speed').min(0.5).max(10).step(0.5).onFinishChange((function(_this) {
      return function() {
        return _this.reInit();
      };
    })(this));
    this.gui.add(params, 'fadeDistance').min(50).max(1000).step(10);
    return this.gui.add(params, 'random').onFinishChange((function(_this) {
      return function() {
        return _this.reInit();
      };
    })(this));
  };

  generateParticles = function() {
    var i, j, material, point, pointGeo, randomVectorComponent, ref, vector;
    randomVectorComponent = function() {
      return Math.random() * 2 * params.speed - params.speed;
    };
    pointGeo = new THREE.Geometry;
    pointGeo.vectors = [];
    for (i = j = 1, ref = params.numberOfParticles; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
      point = new THREE.Vector3(0, 0, 0);
      pointGeo.vertices.push(point);
      vector = (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(THREE.Vector3, (function() {
        var k, results;
        results = [];
        for (i = k = 1; k <= 3; i = ++k) {
          results.push(randomVectorComponent());
        }
        return results;
      })(), function(){});
      vector.setLength(params.initialSphereRadius * Math.random() * 2);
      pointGeo.vectors.push(vector);
      pointGeo.colors.push(new THREE.Color(0xffffff));
    }
    material = new THREE.PointCloudMaterial({
      size: params.size,
      vertexColors: THREE.VertexColors
    });
    return new THREE.PointCloud(pointGeo, material);
  };

  Explody.prototype.update = function() {
    var distance, fadeDistance, i, j, len, ref, vertex;
    if (!this.particles) {
      return;
    }
    fadeDistance = params.fadeDistance;
    ref = this.particles.geometry.vertices;
    for (i = j = 0, len = ref.length; j < len; i = ++j) {
      vertex = ref[i];
      vertex.add(this.particles.geometry.vectors[i]);
      distance = (fadeDistance - Math.min(vertex.length(), fadeDistance)) / fadeDistance;
      this.particles.geometry.colors[i].setHSL((params.random ? Math.random() : 1.0), 1.0, distance);
    }
    this.particles.geometry.verticesNeedUpdate = true;
    return this.particles.geometry.colorsNeedUpdate = true;
  };

  Explody.prototype.render = function() {
    return this.renderer.render(this.scene, this.camera);
  };

  Explody.prototype.renderLoop = function() {
    this.update();
    requestAnimationFrame(this.renderLoop);
    return this.render();
  };

  return Explody;

})();
